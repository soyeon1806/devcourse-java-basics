# Day 03

## 💡 주제
```
📌 변수
   ➡️ 인스턴수 변수, 클래스 변수, 지역 변수의 선언과 초기화, 사용 범위(scope) 이해하기
📌 생성자
   ➡️ 생성자의 역할과 오버로딩, this()를 사용한 생성자 호출 방법 이해하기
📌 배열
   ➡️ 1차원 및 2차원 배열의 선언, 초기화, 활용법 및 참조 자료형 배열 이해하기
📌 메서드
   ➡️ 메서드의 선언, 호출, 오버로딩 및 가변 인자 사용법 이해하기
📌 상속과 오버라이딩
   ➡️ 자바의 상속 개념과 메서드 오버라이딩, 그리고 다형성 이해하기
📌 캡슐화
   ➡️ 캡슐화의 원리, private 필드 및 getter, setter 메서드를 통한 데이터 보호 이해하기
📌 final 키워드
   ➡️ final 키워드를 사용한 상수 선언, 메서드 오버라이딩 금지, 클래스 상속 금지에 대해 이해하기
📌 접근 제어자
   ➡️ public, private, protected, default 접근 제어자의 사용법과 특징 이해하기
📌 메모리 구조
   ➡️ 스택과 힙 메모리의 역할 및 참조 자료형의 저장 공간 이해하기
📌 this와 super 키워드
   ➡️ this와 super 키워드를 사용하여 인스턴스 및 부모 클래스 멤버에 접근하는 방법 이해하기
```

## 📄 파일 설명
| 파일명 | 내용 |
|:--   |:--      |
| Ex01_Variable01 ~ Ex13_Variable03 | 변수의 선언과 초기화, 스코프(변수의 유효 범위), 인스턴스 및 클래스 변수와 메소드에 대한 예제 |
| Ex04_Constructor01 ~ Ex06_Constructor04 | 생성자의 기본 개념, 오버로딩, this()를 사용한 생성자 호출 예제 |
| Ex07_This01 | this 키워드를 사용하여 같은 클래스 내의 다른 생성자를 호출하는 방법을 설명하는 예제 |
| Ex08_Array01 | 기본 자료형과 참조 자료형 배열의 선언, 초기화, 사용에 대한 예제 |


## ✏️ 정리

### 자바 명명 규칙

#### 1. 클래스명 규칙
**1) 클래스명은 대문자로 시작**
  - 자바 클래스의 이름은 반드시 대문자로 시작해야 함
  - **ex)** `Person`, `Employee`, `Car`

**2) 파스칼케이스 사용**  
  - 클래스명에 두 개 이상의 단어가 포함될 때는 단어의 첫 글자를 대문자로 표기하는 **파스칼케이스(PascalCase)** 방식으로 작성함  
  - **ex)** `StudentRecord`, `BankAccount`, `CustomerInfo`

**3) 예약어 사용 금지**
  - 자바의 예약어(Reserved Keywords)는 클래스 이름으로 사용할 수 없음  
  - **ex)** `class`, `int`, `public` 같은 단어는 사용할 수 없음

**4) 특수문자 사용 금지**  
  - 숫자나 언더스코어(_) 외에 특수문자는 클래스명에 사용할 수 없음 
  - **ex)** `MyClass_1` (허용됨), `My-Class` (허용되지 않음)

**5) 숫자는 첫 글자에 사용 금지**  
  - 숫자는 클래스명의 첫 글자에 올 수 없음  
  - **ex)** `Person1` (허용됨), `1Person` (허용되지 않음)

**6) 클래스명은 의미 있게** 
  - 클래스 이름은 클래스가 나타내는 개념이나 역할을 명확하게 설명할 수 있도록 의미 있는 이름으로 지어야 함
  **ex)** `Student`, `Invoice`, `ProductManager`

**7) 파일명과 클래스명 일치**  
  - 클래스의 이름은 파일명과 동일해야 함  
  **ex)** `Person.java` 파일 안에 `Person` 클래스가 정의되어야 함


#### 2. 상수명 규칙
**1) 대문자 사용**  
  - 상수(constant)는 모두 대문자로 작성하며, 각 단어는 언더스코어(_)로 구분함  
  - **ex)** `MAX_SPEED`, `PI`, `DEFAULT_TIMEOUT`

**2) 의미 있는 이름**  
  - 상수는 고정된 값이나 불변의 의미를 전달해야 하므로, 이름이 명확하고 구체적이어야 함  
  **ex)** `MAX_USERS`, `MIN_AGE_LIMIT`


#### 3. 메소드명 규칙
**1) 카멜케이스 사용**  
  - 메소드명은 소문자로 시작하며, 여러 단어가 결합될 때는 카멜케이스(CamelCase)를 함
  - **ex)** `calculateTotal()`, `getUserName()`, `setAge()`

**2) 동사로 시작**  
  - 메소드명은 동사로 시작하는 것이 일반적임
  -  메소드는 보통 어떤 동작을 수행하므로 그 동작을 명확하게 표현하는 동사를 사용함  
  - **ex)** `printDetails()`, `saveData()`, `fetchRecords()`

**3) 의미 있는 이름**  
  - 메소드명은 메소드가 하는 일을 명확히 나타내야 함  
  **ex)** `getTotalPrice()`, `sendEmail()`


#### 4. 메소드 오버로딩 규칙
**1) 오버로딩**  
  - 같은 메소드명을 사용하되, 매개변수가 다르게 선언되어야 함

<br><br><br>

### 변수의 사용 영역 (Scope, 범위)

**1) 클래스 변수 (Class Variable)**
   - `static` 키워드로 선언된 변수.
   - 클래스가 메모리에 로드될 때 생성되며, **모든 인스턴스가 공유**함
   - 클래스 이름으로 직접 접근 가능하며, 접근 제한자에 따라 외부 접근 가능 여부가 달라짐
   - **ex)** `public static int counter;`

**2) 인스턴스 변수 (Instance Variable)**
   - 클래스 내에서 선언되지만 `static` 키워드가 없는 변수
   - 각 인스턴스마다 **독립적으로 생성**되며, 인스턴스가 있어야 접근 가능
   - **ex)** `public String name;`

**3) 지역 변수 (Local Variable)**
   - 메소드나 블록 내에서 선언된 변수
   - 해당 **메소드나 블록 내에서만 사용 가능**하며, 메소드가 종료되면 사라짐
   - **ex)** `int age = 25;` (메소드 내 선언된 변수)

**4) 매개변수 (Parameter Variable)**
   - 메소드에 **전달된 인자**를 받는 변수
   - 해당 메소드 내에서만 사용 가능하며, 메소드 호출 시 생성되고, 메소드가 종료되면 사라짐
   - **ex)** `public void setName(String name) {}`

**5) 블록 내 변수 (Block Variable)**
   - **제어문**(if, for, while 등) 안에서 선언된 변수
   - 해당 **블록 내에서만 유효**하며, 블록이 끝나면 사라짐
   - **ex)** `for (int i = 0; i < 10; i++) {}` (for 블록 내의 `i`)

<br><br><br>

### 자바 자료형별 초기화 값 정리

- 자바에서 인스턴스 변수는 자동으로 초기화됨<br>
- 각 자료형별 기본 초기화 값은 아래와 같음

| 자료형         | 초기화 값     |
|:---------------|:--------------|
| byte           | 0             |
| short          | 0             |
| int            | 0             |
| long           | 0L            |
| float          | 0.0f          |
| double         | 0.0d          |
| char           | '\u0000'      |  <!-- 빈 문자 -->
| boolean        | false         |
| 참조형 (String 포함) | null  |


#### 참고
- **기본 자료형(Primitive types)** 은 각각 고유한 초기화 값을 가지며, 이 값들은 인스턴스 변수를 선언할 때 명시적으로 값을 지정하지 않아도 자동으로 할당됨
- **참조형(Reference types)**, 즉 객체나 배열, `String` 등의 변수는 자동으로 `null`로 초기화됨
- **지역 변수(Local variables)** 는 자동으로 초기화되지 않으므로, 사용하기 전에 반드시 초기화해야 함


<br><br><br>

### this() 정리

- `this()`는 **같은 클래스의 다른 생성자를 호출할 때** 사용되며, **코드 중복을 줄이고** 생성자 간의 **공통 로직을 관리**하는 데 유용함<br>
- 주로 생성자가 여러 개일 때, 공통 초기화 작업을 하나의 생성자에서만 정의하고 다른 생성자에서 이를 호출하는 방식으로 활용됨


#### 사용 규칙
**1) 첫 번째 문장**
- `this()`는 생성자 내에서 반드시 **첫 번째 문장**으로 사용되어야 함
- 그렇지 않으면 **컴파일 에러**가 발생함

**2) 생성자 내부에서만 사용 가능**
- `this()`는 오직 **생성자 내부에서만** 사용 가능하며, 일반 메서드나 블록에서는 사용할 수 없음


#### 주의사항
**1) 자기 호출 불가**
- `this()`를 사용하여 **자기 자신을 호출**하거나, 순환 참조를 만들 수 없음<br>
  -> 이는 **무한 루프**를 방지하기 위한 규칙임

**2) 순환 참조 금지**
- `this()`가 여러 생성자를 순환 참조하게 되면, 무한 루프가 발생하여 프로그램이 중단될 수 있으므로 이를 방지하기 위해 제한이 있음

#### 예시:
```java
class Example {
    Example() {
        System.out.println("기본 생성자 호출");
    }

    Example(String name) {
        this(); // 기본 생성자 호출
        System.out.println("오버로딩된 생성자 호출");
    }
}
```

<br><br><br>

### 상속(Inheritance)
- **상속**은 자바에서 기존 클래스(부모 클래스)의 기능을 새로운 클래스(자식 클래스)가 물려받아 사용할 수 있게 하는 기능임<br>
- 상속을 통해 **코드의 재사용성을 높이고**, **유지보수성을 향상**시킬 수 있음

#### 상속의 기본 개념
- **부모 클래스(상위 클래스)**
  - 공통적인 속성이나 동작을 정의한 클래스
- **자식 클래스(하위 클래스)**
  - 부모 클래스를 상속받아, 부모 클래스의 속성과 동작을 물려받음
  - 필요에 따라 새로운 기능을 추가하거나 수정할 수 있음

#### 상속의 문법
```Java
class 부모클래스 {
    // 부모 클래스 멤버(필드, 메소드 등)
}

class 자식클래스 extends 부모클래스 {
    // 자식 클래스 멤버(필드, 메소드 등)
}
```

<br><br><br>

### 오버라이딩(Overriding)
- 오버라이딩은 자식 클래스가 부모 클래스의 메소드를 재정의하는 기능임
- 부모 클래스에서 제공한 메소드를 자식 클래스에서 다시 구현하여, 자식 클래스에 맞는 동작을 수행하도록 할 수 있음

#### 오버라이딩의 기본 문법
- 부모 클래스의 메소드 이름, 반환 타입, 매개변수가 동일해야 함
- 오버라이딩된 메소드는 자식 클래스에서 부모 클래스의 메소드를 덮어씀

```Java
@Override  // 오버라이딩임을 명시 (선택사항)
public void 메소드이름() {
    // 재정의된 메소드 내용
}
```

<br><br><br>

### `super` 키워드

- `super`는 **부모 클래스의 멤버(필드, 메소드, 생성자)에 접근**하기 위해 사용되는 특별한 키워드임

#### super 사용의 규칙
- **첫 번째 줄에 위치**
  - 생성자에서 `super()`는 항상 **첫 번째 줄**에서 호출되어야 함
- **부모 클래스와 관계**
  - `super`는 **부모 클래스의 멤버**에 접근할 때만 사용되며, 조부모 클래스의 멤버에는 직접적으로 접근할 수 없음
- **super() 생략 가능**
  - 자식 클래스에서 생성자를 정의할 때 부모 클래스의 기본 생성자를 호출하는 `super()`는 **생략 가능**함<br>
  - 그러나 부모 클래스에 **기본 생성자가 없거나**, **매개변수가 있는 생성자**를 호출해야 하는 경우에는 반드시 명시적으로 `super()`를 사용해야 함

#### this와 super의 차이

| 키워드   | 설명                                          |
|----------|-----------------------------------------------|
| `this`   | 같은 클래스의 필드나 메소드를 참조할 때 사용  |
| `super`  | 부모 클래스의 필드나 메소드를 참조할 때 사용  |
| `this()` | 같은 클래스의 다른 생성자를 호출할 때 사용   |
| `super()`| 부모 클래스의 생성자를 호출할 때 사용         |

<br><br><br>

### `final` 키워드

- `final` 키워드는 **한 번만 값을 할당**할 수 있음을 나타내며, 변경이 불가능한 **상수**, **메소드**, **클래스** 등을 정의할 때 사용함

#### `final` 변수:
- **값을 한 번만 할당**할 수 있는 상수를 선언할 때 사용함
- 기본 자료형의 경우, **값을 변경할 수 없으며** 재할당이 불가능함.
- 참조 자료형의 경우, **참조하는 객체를 변경할 수 없지만**, **객체의 내부 상태는 변경 가능**함


```java
final int MAX_VALUE = 100;  // 기본 자료형 상수
final Book myBook = new Book();  // 참조 자료형 상수 (객체는 변경 불가능, 내부 상태는 변경 가능)
```

#### `final` 메서드
- 메서드에 `final`을 붙이면 **오버라이딩을 금지**함
- 즉, 자식 클래스가 해당 메서드를 **재정의(Override)**할 수 없음

```java
class Parent {
    public final void show() {
        System.out.println("부모 클래스의 메서드");
    }
}

class Child extends Parent {
    // @Override  // 에러 발생: 부모 클래스의 메서드를 오버라이딩할 수 없음
    // public void show() { ... }
}
```

#### `final` 클래스
- `final` 클래스를 선언하면 상속을 금지함
- 즉, 다른 클래스가 이 클래스를 확장할 수 없음

```Java
final class Vehicle{
  // 상속이 불가능한 클래스
}

// class Car extends Vehicle { // 에러 발생 : 상속할 수 없음
// }
```

#### `static final` (상수)
- **`static final`** 은 클래스 상수를 정의할 때 사용됨
- **`static`** 은 클래스 수준에서 공유되며, **`final`**은 값을 변경할 수 없음을 나타냄
- **클래스 상수**는 모든 인스턴스에서 동일한 값을 가지며, 변경되지 않는 값을 정의할 때 유용함

```Java
public class Example{
  public static final int MAX_VALUE = 100; //클래스 상수
}
```

<br><br>
```Java
public class FinalExample{
  public static final int MAX_SPEED = 120;\

  public final void displaySpeed(){
    System.out.println("최대 속도 : " + MAX_SPEED);
  }

  public static void main(String[] args){
    FinalExample example = new FinalExample();
    example.displaySpeed();
  }
}
```

<br><br><br>

### 접근 제어자

#### 접근 제어자의 종류와 특징
- 접근 제어자는 클래스, 필드, 메소드에 대한 **접근 범위를 제어**하는 키워드임
- 자바에서는 `public`, `private`, `protected`, 그리고 **default**(기본, 패키지 접근)의 네 가지 접근 제어자가 있으며, 이들로 객체 간의 데이터 접근 범위를 설정할 수 있음

#### 접근 제어자의 종류

| 접근 제어자   | 같은 클래스 | 같은 패키지 | 자식 클래스 | 외부 (전체 접근) |
|---------------|-------------|-------------|-------------|------------------|
| `private`     | O           | X           | X           | X                |
| (기본, default)| O           | O           | X           | X                |
| `protected`   | O           | O           | O           | X                |
| `public`      | O           | O           | O           | O                |


#### 주목할 두 가지 접근 제어자
1) `private`
- **클래스 내부에서만 접근**할 수 있음
- 다른 클래스나 외부에서는 접근할 수 없음
- 주로 **캡슐화**의 핵심 요소로 사용되며, **필드나 메소드**를 외부에서 감추고 내부에서만 사용하도록 할 때 사용함

2) `public`
- 어디서든지 **접근이 가능**함
- 즉, 클래스, 패키지, 상속 관계에 상관없이 모든 클래스에서 접근할 수 있음
- 클래스나 메소드가 **공용 API**로 사용될 때 주로 사용함

<br><br><br>

### 캡슐화(Encapsulation)

#### 캡슐화의 정의
- **캡슐화(Encapsulation)**는 객체 지향 프로그래밍(OOP)의 핵심 개념 중 하나로, **데이터(필드)**와 **메소드**를 하나의 단위(클래스)로 묶고, 데이터를 보호하는 것을 의미함
- 캡슐화를 통해 클래스의 내부 상태(필드)는 외부에서 직접 접근하지 못하게 감추고, 오직 **필요한 메소드**를 통해서만 접근하도록 제한함
- 이를 통해 객체의 일관성을 유지하고, 불필요한 데이터 노출을 방지할 수 있음


#### 캡슐화의 주요 목표:
1. **내부 구현 감추기**
- 외부에서 객체의 내부 구현을 알 필요 없이, 제공된 메소드만으로 상호작용할 수 있도록 함<br><br>

2. **데이터 보호**
- 외부에서 직접 데이터를 수정할 수 없으므로, 객체의 상태를 안전하게 보호하고 유지할 수 있음<br><br>

3. **유효성 검증**
- 메소드를 통해 데이터를 수정할 때, 필요한 유효성 검증을 추가할 수 있어, 데이터의 무결성을 유지할 수 있음<br><br>

#### 캡슐화 구현 방법
**1) private 필드**
- 멤버 필드는 `private`으로 선언되어, 외부에서는 직접 접근할 수 없음

**2) Getter와 Setter 메소드**
- 데이터를 외부에서 접근하거나 수정할 때는 `get`과 `set` 메소드를 사용하여, 객체의 상태를 간접적으로 제어함


#### Getter(게터) 메소드
- **Getter 메소드**는 `private` 필드에 저장된 데이터를 외부에서 조회할 수 있도록 하는 **`public` 메소드**임
- 필드를 직접 노출하지 않고, 안전하게 데이터에 접근할 수 있는 방법을 제공함<br><br>

  **Getter 메소드의 구조**
  - 반환값이 있으며, **필드의 데이터 타입**과 동일함
  - 메소드 이름은 보통 **`get` 접두사**에 **필드명**을 붙여서 만듦


#### Setter(세터) 메소드
- **Setter 메소드**는 `private` 필드의 값을 변경할 수 있도록 하는 **`public` 메소드**임
- 필드를 직접 수정하는 대신, 메소드를 통해 **간접적으로 값을 설정**하며, 이 과정에서 **유효성 검사를 추가**하여 잘못된 값이 입력되지 않도록 할 수 있음<br><br>

  **Setter 메소드의 구조**
  - 반환값이 없고(`void`), **매개변수로 필드의 데이터 타입**과 동일한 값을 받음
  - 메소드 이름은 보통 **`set` 접두사**에 **필드명**을 붙여서 만듦<br><br>

#### 캡슐화 예시 코드
```java
public class Person {
    // 필드를 private으로 선언하여 은닉
    private String name;
    private int age;

    // public 메소드를 통해 데이터 접근
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        // 유효성 검사를 통해 객체의 일관성 유지
        if (age > 0) {
            this.age = age;
        }
    }
}
```

<br><br><br>


## 📑 참고
- 온라인 자바 튜토리얼: https://www.w3schools.com/java/